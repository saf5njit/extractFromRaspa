# Author: Santiago A. Flores Roman
# Description: This script extracts the requested data from the data files generated by RASPA.
# Requirements: Numpy, Pandas and matplotlib have to be installed.
# Instructions:
#   This script assumes that there is only one data file per Output/System_#/ directory. The reason
#   is that several points can be run at the same time in Slurm, acceleating the simulation. If there
#   are several data files in one directory, then RASPA will have simulated point by point, which is
#   slow as the program is not parallelized.
#   Run the script as following for more information.
#   python3 extractRaspaData.py -h

import os,re
import warnings
import scipy
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib as mpl
from sklearn.neighbors import KernelDensity
from sys import argv,exit

warnings.filterwarnings("ignore", category=RuntimeWarning)

style = {'font.size': 36,
         'font.family': 'serif',
         'figure.figsize': (10,8),
         'axes.labelsize': '26',
         'axes.titlesize': '26',
         'xtick.labelsize': '26',
         'ytick.labelsize': '26',
         'legend.fontsize': '25',
         'xtick.direction': 'in',
         'ytick.direction': 'in',
         'lines.linewidth': 2,
         'lines.markersize': 12,
         'xtick.major.size': 18,
         'ytick.major.size': 18,
         'axes.grid': False,
         'xtick.top': True,
         'ytick.right': True,
         'text.usetex': True}
mpl.rcParams.update(style)

##########################################################################################################
class Extract():
    def __init__(self,argv):
        self.argv = argv
        self.motor = 'Raspa'
        self.path = './Outputs/System_0/'
        self.units = 'kPa'
        self.sort = 'P'
        self.sections = ['init','prod']
        self.dimensions = ['x','y','z']
        self.angles = ['alpha','beta','gamma']
        self.boxVectors = ['a','b','c']
        self.boxes = [0]
        self.varsToExtract = ['N']
        self.histsToExtract = []
        self.figuresToExtract = []
        self.termalizationInPlots, self.termalizationInHists = 0, 0
        self.components, self.listInFiles, self.outFilePath = [], [], []
        self.outFile = ('outData.dat',False)
        self.printInputParams = self.createFigures = False
        self.kernelDensity = False
        self.fileLines = self.fileNumber = 0
        self.fileName, self.dimLetter = '', ''
        self.append = False
    def Flags(self):
        argv = self.argv
        printInputParams = self.printInputParams
        createFigures = self.createFigures
        path = self.path
        units = self.units
        sort = self.sort
        outFile = self.outFile
        dimensions = self.dimensions
        angles = self.angles
        boxVectors = self.boxVectors
        components = self.components
        boxes = self.boxes
        varsToExtract = self.varsToExtract
        histsToExtract = self.histsToExtract
        figuresToExtract = self.figuresToExtract
        sections = self.sections
        termalizationInPlots = self.termalizationInPlots
        termalizationInHists = self.termalizationInHists
        kernelDensity = self.kernelDensity
        append = self.append
        for i in range(len(argv)):
            argv[i] = argv[i].lower()
            if (argv[i] == '-h'): self.Help()
            if (argv[i] == '-help'): self.Help()
            elif (argv[i] == '-print'): printInputParams = True
            elif (argv[i] == '-kde'): kernelDensity = True
            elif (argv[i] == '-in'): path = argv[i+1]
            elif (argv[i] == '-units'): units = argv[i+1]
            elif (argv[i] == '-sort'): sort = argv[i+1]
            elif (argv[i] == '-out'): outFile = (argv[i+1],True)
            elif (argv[i] == '-thermafigures'): termalizationInPlots = int(float(argv[i+1]))
            elif (argv[i] == '-thermahists'): termalizationInHists = int(float(argv[i+1]))
            elif (argv[i] == '-append'): append = True
            elif (argv[i] == '-dimensions'):
                dimensions = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    dimensions.append(argv[j])
            elif (argv[i] == '-angles'):
                angles = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    angles.append(argv[j])
            elif (argv[i] == '-boxvectors'):
                boxVectors = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    boxVectors.append(argv[j])
            elif (argv[i] == '-components'):
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    components.append(argv[j])
            elif (argv[i] == '-variables'):
                varsToExtract = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    varsToExtract.append(argv[j].lower())
            elif (argv[i] == '-boxes'):
                boxes = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    boxes.append(int(argv[j]))
            elif (argv[i] == '-sections'):
                sections = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    sections.append(argv[j])
            elif (argv[i] == '-hists'):
                histsToExtract = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    histsToExtract.append(argv[j].lower())
            elif (argv[i] == '-figures'):
                figuresToExtract = []
                for j in range(i+1,len(argv)):
                    if (argv[j][0] == '-'): break
                    figuresToExtract.append(argv[j].lower())
        self.printInputParams = printInputParams
        self.createFigures = createFigures
        self.path = path
        self.units = units
        self.sort = sort
        self.outFile = outFile
        self.dimensions = dimensions
        self.angles = angles
        self.boxVectors = boxVectors
        self.components = components
        self.boxes = boxes
        self.varsToExtract = varsToExtract
        self.histsToExtract = histsToExtract
        self.figuresToExtract = figuresToExtract
        self.sections = sections
        self.termalizationInPlots = termalizationInPlots
        self.termalizationInHists = termalizationInHists
        self.kernelDensity = kernelDensity
        self.append = append
    def CreateDataFrame(self,outData):
        sort = self.sort
        keys = list(outData.keys())
        longestKey = keys[0]
        for i in range(1,len(keys)):
            if len(outData[keys[i]]) > len(outData[keys[i-1]]): longestKey = keys[i]
        outData = pd.DataFrame(outData,index=range(len(outData[longestKey])))
        for key in outData.columns:
            findSortKey = re.search(f'^{sort}\[.+',key)
            if findSortKey:
                outData.sort_values(findSortKey.group(),ignore_index=True,inplace=True); break
        return outData
    def CreateOutFile(self,outData,fileNumber):
        append = self.append
        outPath, outFileName, outExtension = self.outFilePath
        if outPath: outPath = f'{outPath}dataFiles/' #If output file is in a subdirectory.
        else: outPath = 'dataFiles/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if append:
            outData.to_csv(f'{outPath}{fileNumber}_{outFileName}{outExtension}',sep='\t',index=False,na_rep='NaN',mode='a',header=False)
        else:
            outData.to_csv(f'{outPath}{fileNumber}_{outFileName}{outExtension}',sep='\t',index=False,na_rep='NaN')
    def ReadOutputFile(self):
        outFile = self.outFile
        outFilePath = re.search(r'^(.+/)?(.+)(\..+)$',outFile[0])
        if not outFilePath.group(3):
            outFilePath = (outFilePath.group(1),outFilePath.group(2),'.dat')
        else:
            outFilePath = outFilePath.group(1,2,3)
        self.outFilePath = outFilePath
        return outFilePath
    def PlotVariables(self,outData,fileNumber):
        term = self.termalizationInPlots
        outPath,outFileName,outExtension = self.outFilePath
        outData[term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
        plt.tight_layout()
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        plt.savefig(f'{outPath}{fileNumber}_{outFileName}.pdf')
    def ExtractData(self):
        listInFiles = self.listInFiles
        varsToExtract = self.varsToExtract
        histsToExtract = self.histsToExtract
        figuresToExtract = self.figuresToExtract
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        for i in range(len(listInFiles)):
            print('\nExtracting data...')
            outData = self.CallExtractors(listInFiles[i]) # From derived class.
            print('\nOrganizing data...')
            outData = self.CreateDataFrame(outData)
            print(outData)
            print(outData.describe())
            if createOutFile:
                outPath, outFileName, outExtension = self.ReadOutputFile()
                if outPath:
                    print(f'\nCreating output file: {outPath}dataFiles/{i}_{outFileName}{outExtension} ...')
                else:
                    print(f'\nCreating output file: dataFiles/{i}_{outFileName}{outExtension} ...')
                self.CreateOutFile(outData,i)
                if createFigures:
                    print('\nCreating figures...')
                    for j in varsToExtract:
                        self.PlotVariables(outData,i,j)
                        print(f'\t{outPath}Figures/{i}_{outFileName}_{j.upper()} ...')
            if figuresToExtract:
                outPath, outFileName, outExtension = self.ReadOutputFile()
                print('\nCreating figures...')
                if outPath:
                    for j in figuresToExtract:
                        self.PlotVariables(outData,i,j)
                        print(f'\t{outPath}Figures/{i}_{outFileName}_{j.upper()} ...')
                else:
                    for j in figuresToExtract:
                        self.PlotVariables(outData,i,j)
                        print(f'\tFigures/{i}_{outFileName}_{j.upper()} ...')
            if histsToExtract:
                outPath, outFileName, outExtension = self.ReadOutputFile()
                print('\nCreating histograms...')
                if outPath:
                    for j in histsToExtract:
                        self.PlotHistograms(outData,i,j)
                        print(f'\t{outPath}histograms/{i}_{outFileName}_{j.upper()} ...')
                else:
                    for j in histsToExtract:
                        self.PlotHistograms(outData,i,j)
                        print(f'\thistograms/{i}_{outFileName}_{j.upper()} ...')
            print(f'\nNormal termination for file {listInFiles[i]}')
        print('\nNormal termination.')
        exit(0)
class Raspa(Extract):
    def __init__(self):
        Extract.__init__(self,argv)
        self.ReadUnits()
    def FindComponents(self,inputFileName):
        with open(inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findComponent = re.search('Component\s\d+\s\((.+?)\)',fileLines[line])
            if findComponent:
                if findComponent.group(1) in self.components: break
                self.components.append(findComponent.group(1))
    def ReadInputFiles(self):
        path = self.path
        listInFiles = []
        for fileName in os.listdir(path):
            if fileName.endswith('.data'): listInFiles.append(fileName)
        self.listInFiles = listInFiles
        self.FindComponents(path+listInFiles[0])
    def ReadUnits(self):
        units = {}
        units['mass'] = 'a.u.'
        units['angle'] = 'degrees'
        units['distance'] = 'A'
        units['volume'] = 'A^3'
        units['time'] = 'ps'
        units['energy'] = 'K'
        units['temperature'] = 'K'
        units['pressure'] = 'Pa'
        units['charge'] = 'a.u.'
        units['density'] = 'kg/m^3'
        units['henry'] = 'mol/kg/Pa'
        self.units = units
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        angles = self.angles
        boxVectors = self.boxVectors
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        components = self.components
        sections = self.sections
        append = self.append
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tFluid components: {components}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tBox angles: {angles}')
        print(f'\tBox vectors: {boxVectors}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print(f'\tAppend new data to collected data: {append}')
        print( '\tInput files:')
        for i in range(len(listInFiles)): print(f'\t\t{listInFiles[i]}')
    def CallExtractors(self,fileName):
        path = self.path
        varsToExtract = self.varsToExtract
        components = self.components
        dimensions = self.dimensions
        angles = self.angles
        boxVectors = self.boxVectors
        units = self.units
        outData = {}
        with open(path+fileName,'r') as fileContent: fileLines = fileContent.readlines()
        if ('v' in varsToExtract):
            unit = units['volume']
            outData[f'V[{unit}]'] = self.ExtractVolumes(fileLines)
        if ('t' in varsToExtract):
            unit = units['temperature']
            outData[f'T[{unit}]'] = self.ExtractTemperatures(fileName,fileLines)
        if ('p' in varsToExtract):
            unit = units['pressure']
            outData[f'P[{unit}]'] = self.ExtractPressures(fileName,fileLines)
        if ('u' in varsToExtract):
            unit = units['energy']
            outData[f'U[{unit}]'] = self.ExtractTotalEnergy(fileLines)
        if ('uhh' in varsToExtract):
            unit = units['energy']
            outData[f'Uhh[{unit}]'] = self.ExtractHostHostEnergy(fileLines)
        if ('uhg' in varsToExtract):
            unit = units['energy']
            outData[f'Uhg[{unit}]'] = self.ExtractHostAdsorbateEnergy(fileLines)
        if ('uhc' in varsToExtract):
            unit = units['energy']
            outData[f'Uhc[{unit}]'] = self.ExtractHostCationEnergy(fileLines)
        if ('ugg' in varsToExtract):
            unit = units['energy']
            outData[f'Ugg[{unit}]'] = self.ExtractAdsorbateAdsorbateEnergy(fileLines)
        if ('ucc' in varsToExtract):
            unit = units['energy']
            outData[f'Ucc[{unit}]'] = self.ExtractCationCationEnergy(fileLines)
        if ('ugc' in varsToExtract):
            unit = units['energy']
            outData[f'Ugc[{unit}]'] = self.ExtractAdsorbateCationEnergy(fileLines)
        if ('mu' in varsToExtract):
            unit = units['energy']
            for comp in components:
                chemPots,deltaChemPots = self.ExtractWidomChemicalPotential(fileLines,comp)
                outData[f'Mu[{unit}] {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData[f'deltaMu[{unit}] {comp}'] = deltaChemPots
        if ('idmu' in varsToExtract):
            unit = units['energy']
            for comp in components:
                chemPots,deltaChemPots = self.ExtractIdealWidomChemicalPotential(fileLines,comp)
                outData[f'IdMu[{unit}] {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData[f'deltaIdMu[{unit}] {comp}'] = deltaChemPots
        if ('exmu' in varsToExtract):
            unit = units['energy']
            for comp in components:
                chemPots,deltaChemPots = self.ExtractExcessWidomChemicalPotential(fileLines,comp)
                outData[f'ExMu[{unit}] {comp}'] = chemPots
                if (len(deltaChemPots) != 0): outData[f'deltaExMu[{unit}] {comp}'] = deltaChemPots
        if ('rho' in varsToExtract):
            unit = units['density']
            for comp in components:
                outData[f'Rho[{unit}] {comp}'] = self.ExtractDensities(fileLines,comp)
        if ('kh' in varsToExtract):
            unit = units['henry']
            for i in range(len(components)):
                outData[f'KH[{unit}] {components[i]}'] = self.ExtractHenryCoefficients(fileLines,i)
        if ('n' in varsToExtract):
            for comp in components:
                outData[f'N {comp}'] = self.ExtractNumberOfMolecules(fileLines,comp)
        if ('l' in varsToExtract):
            unit = units['distance']
            for dim in dimensions:
                outData[f'L_{dim}[{unit}]'] = self.ExtractBoxLengths(fileLines,dim)
        if ('a' in varsToExtract):
            unit = units['angle']
            for ang in angles:
                outData[f'{ang}[{unit}]'] = self.ExtractBoxAngles(fileLines,ang)
        if ('bl' in varsToExtract):
            unit = units['distance']
            df = self.ExtractBoxVectors(fileLines)
            outData[f'a_x[{unit}]'], outData[f'a_y[{unit}]'], outData[f'a_z[{unit}]'] = df[0], df[1], df[2]
            outData[f'b_x[{unit}]'], outData[f'b_y[{unit}]'], outData[f'b_z[{unit}]'] = df[3], df[4], df[5]
            outData[f'c_x[{unit}]'], outData[f'c_y[{unit}]'], outData[f'c_z[{unit}]'] = df[6], df[7], df[8]
        return outData
    def ExtractHenryCoefficients(self,fileLines,ithComp):
        sections = self.sections
        coefs = []
        print('Extracting Henry coefficients.')
        for line in range(len(fileLines)):
            findHenrysCoef = re.search('^Henry coefficients',fileLines[line])
            if findHenrysCoef:
                for subline in range(line+1,len(fileLines)):
                    findCoef = re.search(f'Component\s+{ithComp}:\s+(\d+\.?\d*)\s+\[',fileLines[subline])
                    if findCoef:
                        value = float(findCoef.group(1))
                        if (value == 0): break
                        coefs.append(value)
                        break
        if (len(coefs) == 0):
            print('Warning: No Henry coefficient was found from RASPA.'); coefs.append(np.nan)
        return pd.Series(coefs,index=range(len(coefs)))
    def ExtractVolumes(self,fileLines):
        sections = self.sections
        volumes = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'^Volume:\s+(\d+\.?\d*)\s+\[A\^3\]$',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findVolume = re.search(r'Volume:\s+(\d+\.?\d*).+Average\s+Volume:',fileLines[line])
                    if findVolume: volumes.append(float(findVolume.group(1))) #A^3
        return pd.Series(volumes,index=range(len(volumes)))
    def ExtractPressures(self,fileName,fileLines):
        units = self.units['pressure']
        sections = self.sections
        pressures = []
        for sec in sections:
            if (sec.lower() == 'init'): print('Warning: Pressure is not calculated by RASPA during initialization and equilibration cycles.')
            else:
                for line in range(len(fileLines)):
                    findPressure = re.search(f'Average pressure:.+?(\d+\.\d*)\s+\[{units}\]',fileLines[line])
                    if (findPressure and float(findPressure.group(1)) != 0.0): pressures.append(float(findPressure.group(1)))
        if (len(pressures) == 0):
            print('No molecular pressures were found. Extracting fixed external pressure.')
            findPressure = re.search(r'.+_(.+)\.data',fileName)
            pressures.append(float(findPressure.group(1))) #Pa
        return pd.Series(pressures,index=range(len(pressures)))
    def ExtractTemperatures(self,fileName,fileLines):
        sections = self.sections
        temperatures = []
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Temperature is not calculated by RASPA during initialization cycles.')
                for line in range(len(fileLines)):
                    findTemperature = re.search('^Temperature:\s+(\d+\.?\d*)$',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findTemperature = re.search('Temperature:\s+(\d+\.?\d*).+Translational',fileLines[line])
                    if findTemperature: temperatures.append(float(findTemperature.group(1)))
            if (len(temperatures) == 0):
                print('No molecular temperatures were found. Extracting fixed external temperatures.')
                temperatures.append(float(re.search('.+_(\d+\.?\d*)_.+\.data',fileName).group(1)))
        return pd.Series(temperatures,index=range(len(temperatures)))
    def ExtractTotalEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'init'):
                print('Warning: Total energy is not calculated by RASPA during initialization, equilibration and production cycles.')
                print('Conserved energy will be extracted. It is calculated after initialization cycles (from equilibration and production cycles).')
                for line in range(len(fileLines)):
                    findEnergy = re.search('^Conserved\senergy:\s+(-?\d+\.?\d*)',fileLines[line])
                    if findEnergy: energies.append(float(findEnergy.group(1)))
                if (len(energies) == 0):
                    print('Warning: There was no conserved energy to extract. Extracting current energies per cycle.')
                    for line in range(len(fileLines)):
                        findEnergy = re.search('Current total potential energy:\s+(-?\d+\.?\d*)',fileLines[line])
                        if findEnergy: energies.append(float(findEnergy.group(1)))
            elif (sec.lower() == 'prod'):
                print('Extracting current total energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current total potential energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractHostHostEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current host-host energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Host-Host energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No host-host energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractHostAdsorbateEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current host-adsorbate energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Host-Adsorbate energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No host-adsorbate energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractHostCationEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current host-cation energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Host-Cation energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No host-cation energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractAdsorbateAdsorbateEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current adsorbate-adsorbate energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Adsorbate-Adsorbate energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No adsorbate-adsorbate energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractCationCationEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current cation-cation energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Cation-Cation energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No cation-cation energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractAdsorbateCationEnergy(self,fileLines):
        sections = self.sections
        energies = []
        for sec in sections:
            if (sec.lower() == 'prod'):
                print('Extracting current adsorbate-cation energies per cycle.')
                for line in range(len(fileLines)):
                    prodEnergies = re.search('^Current cycle:\s+0',fileLines[line])
                    if prodEnergies:
                        for subline in range(line+1,len(fileLines)):
                            findEnergy = re.search('Current Adsorbate-Cation energy:\s+(-?\d+\.?\d*)',fileLines[subline])
                            if findEnergy: energies.append(float(findEnergy.group(1)))
        if (len(energies) == 0):
            print('Warning: No adsorbate-cation energy was found from RASPA.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))
    def ExtractDensities(self,fileLines,component):
        sections = self.sections
        densities = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\[kg',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findDensity = re.search(f'Component.+\({component}\).+density:\s+(\d+\.?\d*)\s+\(',fileLines[line])
                    if findDensity: densities.append(float(findDensity.group(1))) #kg/m^3
        return pd.Series(densities,index=range(len(densities)))
    def ExtractBoxLengths(self,fileLines,dimLetter):
        sections = self.sections
        dimension = {'x':1,'y':2,'z':3}
        boxLengths = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findLength = re.search('Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+Box-lengths',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
            if (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findLength = re.search('Box-lengths:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*).+Average',fileLines[line])
                    if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
        return pd.Series(boxLengths,index=range(len(boxLengths)))
    def ExtractBoxAngles(self,fileLines,dimLetter):
        dimension = {'alpha':1,'beta':2,'gamma':3}
        boxLengths = []
        for line in range(len(fileLines)):
            findLength = re.search('Box-angles:\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*).+Average',fileLines[line])
            if findLength: boxLengths.append(float(findLength.group(dimension[dimLetter]))) #A
        return pd.Series(boxLengths,index=range(len(boxLengths)))
    def ExtractBoxVectors(self,fileLines):
        boxVectorAx, boxVectorAy, boxVectorAz = [], [], []
        boxVectorBx, boxVectorBy, boxVectorBz = [], [], []
        boxVectorCx, boxVectorCy, boxVectorCz = [], [], []
        for line in range(len(fileLines)):
            findBoxVectors = re.search('Current Box:',fileLines[line])
            if findBoxVectors: 
                vectorA = re.search('Current Box:\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*).+Average',fileLines[line])
                vectorB = re.search('\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*).+\[',fileLines[line+1])
                vectorC = re.search('\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*)\s+(-?\d+\.?\d*).+\[',fileLines[line+2])
                boxVectorAx.append(float(vectorA.group(1))); boxVectorAy.append(float(vectorA.group(2))); boxVectorAz.append(float(vectorA.group(3)))
                boxVectorBx.append(float(vectorB.group(1))); boxVectorBy.append(float(vectorB.group(2))); boxVectorBz.append(float(vectorB.group(3)))
                boxVectorCx.append(float(vectorC.group(1))); boxVectorCy.append(float(vectorC.group(2))); boxVectorCz.append(float(vectorC.group(3)))
        tmp = np.array([boxVectorAx,boxVectorAy,boxVectorAz,boxVectorBx,boxVectorBy,boxVectorBz,boxVectorCx,boxVectorCy,boxVectorCz]).T
        return pd.DataFrame(tmp,index=range(len(tmp)))
    def ExtractNumberOfMolecules(self,fileLines,component):
        sections = self.sections
        nMolecules = []
        for sec in sections:
            if (sec.lower() == 'init'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/\d+/\d+,',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)):
                    findAmountMolecules = re.search(f'Component.+\({component}\).+molecules:\s+(\d+)/.+\(',fileLines[line])
                    if findAmountMolecules: nMolecules.append(float(findAmountMolecules.group(1)))
        return pd.Series(nMolecules,index=range(len(nMolecules)))
    def ExtractWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom chemical potential:',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\]\s+Average.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot:
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findChemPot = re.search(f'Component\s+\[{component}\].+average chemical potential:\s+(-?\d+\.?\d*)',fileLines[line]) #J/kb
                        if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0):
            print('Warning: None chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
    def ExtractIdealWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Ideal-gas Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom Ideal-gas contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+Ideal-gas.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot:
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read ideal-gas chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current ideal-gas chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('ideal-gas.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0):
            print('Warning: None ideal-gas chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
    def ExtractExcessWidomChemicalPotential(self,fileLines,component):
        sections = self.sections
        for sec in sections:
            chemPots,deltaChemPots = [],[]
            if (sec.lower() == 'init'):
                print('Warning: Excess Chemical potential is not calculated by RASPA during initialization and equilibration cycles.')
            elif (sec.lower() == 'prod'):
                for line in range(len(fileLines)-1,0,-1):
                    findChemPot = re.search('Average Widom excess contribution',fileLines[line])
                    if findChemPot:
                        for subline in range(line+8,len(fileLines),7):
                            chemPot = re.search(f'\[{component}\].+excess chemical.+?(-?\d+\.?\d*)\s+.+?(\d+\.?\d*)',fileLines[subline])
                            if chemPot:
                                chemPots.append(float(chemPot.group(1))) #J/kb
                                deltaChemPots.append(float(chemPot.group(2))) #J/kb
                                break
                        break
                if not findChemPot:
                    print('Warning: Tried to read excess chemical potential, but simulation hasn\'t ended properly.')
                    print('Extracting current excess chemical potentials per cycle.')
                    for line in range(len(fileLines)):
                        findWidom = re.search(f'Component \[{component}\] average Widom',fileLines[line])
                        if findWidom:
                            findChemPot = re.search('excess chemical.+?(-?\d+\.?\d*)',fileLines[line+1]) #J/kb
                            if findChemPot: chemPots.append(float(findChemPot.group(1)))
        if (len(chemPots) == 0):
            print('Warning: None excess chemical potential was found from RASPA.'); chemPots.append(np.nan)
        if (len(chemPots) == 0): deltaChemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots))),pd.Series(deltaChemPots,index=range(len(deltaChemPots)))
    def PlotHistograms(self,outData,fileNumber,variable):
        term = self.termalizationInHists
        components = self.components
        dimensions = self.dimensions
        angles = self.angles
        units = self.units
        outPath,outFileName,outExtension = self.outFilePath
        kde = self.kernelDensity
        if outPath: outPath += 'histograms/' #If output file is in a subdirectory.
        else: outPath = 'histograms/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            unit = units['volume']
            plt.figure()
            sns.histplot(data=outData[f'V[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'V[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$V$ [\\r{A}$^3$]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_V.pdf')
        if ('t' == variable):
            unit = units['temperature']
            plt.figure()
            sns.histplot(data=outData[f'T[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'T[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$T$ [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_T.pdf')
        if ('p' == variable):
            unit = units['pressure']
            plt.figure()
            sns.histplot(data=outData[f'P[{unit}]]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'P[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'$P$ [{units}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_P.pdf')
        if ('u' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'U[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'U[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_U.pdf')
        if ('uhh' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Uhh[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Uhh[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (host-host) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Uhh.pdf')
        if ('uhg' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Uhg[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Uhg[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (host-adsorbate) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Uhg.pdf')
        if ('uhc' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Uhc[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Uhc[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (host-cation) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Uhc.pdf')
        if ('ugg' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Ugg[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Ugg[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (adsorbate-adsorbate) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Ugg.pdf')
        if ('ucc' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Ucc[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Ucc[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (cation-cation) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Ucc.pdf')
        if ('ugc' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'Ugc[{unit}]'][term:],bins=50,discrete=False,stat='density')
            if kde: sns.kdeplot(data=outData[f'Ugc[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$ (adsorbate-cation) [K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Ugc.pdf')
        if ('mu' == variable):
            unit = units['energy']
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'Mu[{unit}]'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'Mu[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$\mu$ [K]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Mu_{comp}.pdf')
        if ('idmu' == variable):
            unit = units['energy']
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'IdMu[{unit}]'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'IdMu[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$\mu_{\\rm id}$ [K]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_IdMu_{comp}.pdf')
        if ('exmu' == variable):
            unit = units['energy']
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'ExMu[{unit}] {comp}'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'T[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$\mu_{\\rm ex}$ [K]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_ExMu_{comp}.pdf')
        if ('rho' == variable):
            unit = units['volume']
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'Rho[{unit}] {comp}'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'Rho[{unit}] {comp}'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$\\rho$ [kg/m$^3$]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Rho_{comp}.pdf')
        if ('n' == variable):
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'N {comp}'][term:],bins=50,discrete=True,stat='probability')
                if kde: sns.kdeplot(data=outData[f'N {comp}'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$N$')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_N_{comp}.pdf')
        if ('kh' == variable):
            unit = units['henry']
            for comp in components:
                plt.figure()
                sns.histplot(data=outData[f'KH[{unit}] {comp}'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'KH[{unit}] {comp}'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel('$K_H$ [mol/kg/Pa]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_KH_{comp}.pdf')
        if ('l' == variable):
            unit = units['distance']
            for dim in dimensions:
                plt.figure()
                sns.histplot(data=outData[f'L_{dim}[{unit}]'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'L_{dim}[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel(f'$L_{dim}$ [\\r{{A}}]')
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_L_{dim}.pdf')
        if ('a' == variable):
            unit = units['angle']
            for ang in angles:
                plt.figure()
                sns.histplot(data=outData[f'{ang}[{unit}]'][term:],bins=50,discrete=False,stat='density')
                if kde: sns.kdeplot(data=outData[f'{ang}[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel(f'$\{ang}$ [degrees]')
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_{ang}.pdf')
        if ('bl' == variable):
            unit = units['distance']
            vectors = ['a','b','c']
            dimensions = ['x','y','z']
            for vec in vectors:
                for dim in dimensions:
                    plt.figure()
                    sns.histplot(data=outData[f'{vec}_{dim}[{unit}]'][term:],bins=50,discrete=False,stat='density')
                    if kde: sns.kdeplot(data=outData[f'{vec}_{dim}[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
                    plt.xlabel(f'${vec}_{dim}$ [\\r{{A}}]')
                    plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-{vec}_{dim}.pdf')
    def PlotVariables(self, outData,fileNumber,variable):
        term = self.termalizationInPlots
        dimensions = self.dimensions
        angles = self.angles
        components = self.components
        units = self.units
        outPath,outFileName,outExtension = self.outFilePath
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            unit = units['volume']
            plt.figure()
            outData[f'V[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.ylabel('$V$ [\\r{A}$^3$]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-V.pdf')
        if ('t' == variable):
            unit = units['temperature']
            plt.figure()
            outData[f'T[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'T [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-T.pdf')
        if ('p' == variable):
            unit = units['pressure']
            plt.figure()
            outData[f'P[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'P [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-P.pdf')
        if ('u' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'$U$[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'U [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-U.pdf')
        if ('uhh' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Uhh[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (host-host) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Uhh.pdf')
        if ('uhg' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Uhg[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (host-adsorbate) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Uhg.pdf')
        if ('uhc' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Uhc[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (host-cation) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Uhc.pdf')
        if ('ugg' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Ugg[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (adsorbate-adsorbate) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Ugg.pdf')
        if ('ucc' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Ucc[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (cation-cation) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Ucc.pdf')
        if ('ugc' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Ugc[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$U$ (adsorbate-cation) [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Ugc.pdf')
        if ('rho' == variable):
            unit = units['density']
            for comp in components:
                plt.figure()
                outData[f'Rho[{unit}] {comp}'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'$\\rho$ [kg/m$^3$] ({comp})')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Rho_{comp}.pdf')
        if ('n' == variable):
            for comp in components:
                plt.figure()
                outData[f'N {comp}'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'N {comp}')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-N_{comp}.pdf')
        if ('kh' == variable):
            unit = units['henry']
            for comp in components:
                plt.figure()
                outData[f'KH[{unit}] {comp}'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'$K_H$ [{unit}]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_KH_{comp}.pdf')
        if ('mu' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Mu[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$\mu$ [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Mu.pdf')
        if ('l' == variable):
            unit = units['distance']
            for dim in dimensions:
                plt.figure()
                outData[f'L_{dim}[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'$L_{dim}$ [\\r{{A}}]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-L_{dim}.pdf')
        if ('a' == variable):
            unit = units['angle']
            for ang in angles:
                plt.figure()
                outData[f'{ang}[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'$\{ang}$ [degrees]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-{ang}.pdf')
        if ('bl' == variable):
            unit = units['distance']
            vectors = ['a','b','c']
            dimensions = ['x','y','z']
            for vec in vectors:
                for dim in dimensions:
                    plt.figure()
                    outData[f'{vec}_{dim}[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                    plt.ylabel(f'${vec}_{dim}$ [\\r{{A}}]')
                    plt.tight_layout()
                    plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-{vec}_{dim}.pdf')
class MezCal(Extract):
    def __init__(self): 
        Extract.__init__(self,argv)
        self.listLogFiles = []
        self.unitStyle = ''
        self.ReadUnits()
    def FindComponents(self,inputFileName):
        components = []
        with open(inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findComponent = re.search('FluidName\s+(.+);',fileLines[line], re.I)
            if findComponent: components.append(findComponent.group(1).lower())
        self.components = components
    def ReadInputFiles(self):
        path = self.path
        listInputFiles, listLogFiles = [], []
        molFileFound = False 
        for root, dirs, files in os.walk(path):
            for fileName in files:
                if fileName.endswith('.inp'): listInputFiles.append(os.path.join(root, fileName))
                elif fileName.endswith('.log'): listLogFiles.append(os.path.join(root, fileName))
        if len(listInputFiles) == 0: print('Error: Input file not found. Exiting.'); exit(2)
        listInputFiles.sort(), listLogFiles.sort()
        self.listInFiles = listInputFiles
        self.listLogFiles = listLogFiles
        self.FindComponents(listInputFiles[0])
    def ReadUnits(self):
        units = {}
        unitStyle = 'generic'
        units['mass'] = 'g/mol'
        units['distance'] = 'A'
        units['volume'] = 'A^3'
        units['energy'] = 'K'
        units['temperature'] = 'K'
        units['pressure'] = 'Pa'
        units['density'] = 'g/cm^3'
        self.units = units
        self.unitStyle = unitStyle
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        listLogFiles = self.listLogFiles
        components = self.components
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tFluid components: {components}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print(f'\tInput files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listInFiles[i]}')
        print(f'\tLog files:')
        for i in range(len(listLogFiles)):
            print(f'\t\t{listLogFiles[i]}')
    def ReadOutputFile(self, fileName):
        outFile = self.outFile
        box = re.search('.+/(box\d*)/.+', fileName).group(1)
        outFilePath = re.search(r'^(.+/)?(.+)(\..+)$',outFile[0])
        outFileName = f'{box}_{outFilePath.group(2)}'
        if not outFilePath.group(3): 
            outFilePath = (outFilePath.group(1), outFileName, '.dat')
        else: outFilePath = (outFilePath.group(1), outFileName, outFilePath.group(3))
        self.outFilePath = outFilePath
        return outFilePath
    def ExtractData(self):
        listLogFiles = self.listLogFiles
        varsToExtract = self.varsToExtract
        figuresToExtract = self.figuresToExtract
        histsToExtract = self.histsToExtract
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        components = self.components
        for comp in components:
            for i in range(len(listLogFiles)):
                if re.search(f'simulation_{comp}', listLogFiles[i]):
                    print('\nExtracting data...')
                    outData = self.CallExtractors(listLogFiles[i]) # From derived class.
                    print('\nOrganizing data...')
                    outData = self.CreateDataFrame(outData)
                    print(outData)
                    print(outData.describe())
                    if createOutFile:
                        outPath, outFileName, outExtension = self.ReadOutputFile(listLogFiles[i])
                        if outPath:
                            print(f'\nCreating output file: {outPath}dataFiles/{i}_{comp}_{outFileName}{outExtension} ...')
                        else: 
                            print(f'\nCreating output file: dataFiles/{i}_{comp}_{outFileName}{outExtension} ...')
                        self.CreateOutFile(outData,i)
                        if figuresToExtract: 
                            print('\nCreating figures...')
                            for j in figuresToExtract: 
                                self.PlotVariables(outData,i,j,comp)
                                print(f'\t{outPath}Figures/{i}_{outFileName}_{j.upper()}_{comp} ...')
                    else:
                        if figuresToExtract: 
                            _ = self.ReadOutputFile()
                            print('\nCreating figures...')
                            for j in figuresToExtract: 
                                self.PlotVariables(outData,i,j,comp)
                                print(f'\tFigures/{i}_{outFileName}_{j.upper()}_{comp} ...')
                    if histsToExtract:
                        outPath, outFileName, outExtension = self.ReadOutputFile(listLogFiles[i])
                        print(f'\nCreating histograms...')
                        if outPath:
                            for j in histsToExtract: 
                                self.PlotHistograms(outData,i,j,comp)
                                print(f'\t{outPath}histograms/{i}_{outFileName}_{j.upper()}_{comp} ...')
                        else: 
                            for j in histsToExtract: 
                                self.PlotHistograms(outData,i,j,comp)
                                print(f'\thistograms/{i}_{outFileName}_{j.upper()}_{comp} ...')
                    print(f'\nNormal termination for file {listLogFiles[i]}')
        print(f'\nNormal termination.')
        exit(0)
    def CallExtractors(self, fileName): #Check for pressures!
        varsToExtract = self.varsToExtract
        components = self.components
        units = self.units
        outData = {}
        dataFrame = pd.read_csv(fileName, delimiter='\t')
        if ('s' in varsToExtract):
            outData['Set'] = dataFrame['Set']
        if ('v' in varsToExtract):
            unit = units['volume']
            outData[f'V[{unit}]'] = dataFrame['Volume[AA^3]']
        if ('t' in varsToExtract):
            unit = units['temperature']
            outData[f'T[{unit}]'] = dataFrame['Temp[K]']
        if ('p' in varsToExtract):
            unit = units['pressure']
            outData[f'P[{unit}]'] = self.ExtractPressures(fileName)
        if ('u' in varsToExtract):
            unit = units['energy']
            outData['U[K]'] = dataFrame['E/particle[K]']
        if ('uff' in varsToExtract):
            unit = units['energy']
            outData['Uff[K]'] = dataFrame['ffE/particle[K]']
        if ('usf' in varsToExtract):
            unit = units['energy']
            outData['Usf[K]'] = dataFrame['sfE/particle[K]']
        if ('mu' in varsToExtract):
            unit = units['energy']
            outData[f'Mu[{unit}]'] = dataFrame['mu[K]']
        if ('exmu' in varsToExtract):
            unit = units['energy']
            outData[f'ExMu[{unit}]'] = dataFrame['muEx[K]']
        if ('n' in varsToExtract): outData['N'] = dataFrame['NParts']
        if ('rho' in varsToExtract):
            unit = units['density']
            outData[f'Rho[{unit}]'] = dataFrame['Dens[g/cm^3]']
        if ('l' in varsToExtract):
            unit = units['distance']
            dim = 'x'
            outData[f'L_{dim}[{unit}]'] = dataFrame[f'width[AA]']
        return outData
    def ExtractPressures(self,fileName):
        units = self.units['pressure']
        pressures = []
        print('Warning: MezCal does not print pressures. Attempting to extract fixed external pressure from path.')
        pressure = re.search(f'.+_(\d+\.\d*)pa/',fileName)
        pressures.append(float(pressure.group(1)))
        return pd.Series(pressures,index=range(len(pressures)))
    def PlotVariables(self, outData, fileNumber, variable, comp):
        term = self.termalizationInPlots
        dimensions = self.dimensions
        units = self.units
        outPath,outFileName,outExtension = self.outFilePath
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            unit = units['volume']
            plt.figure()
            outData[f'V[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.ylabel(f'V [\\r{A}$^3$]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-V.pdf')
        if ('t' == variable):
            unit = units['temperature']
            plt.figure()
            outData[f'T[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'T [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-T.pdf')
        if ('p' == variable):
            unit = units['pressure']
            plt.figure()
            outData[f'P[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'P [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-P.pdf')
        if ('u' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'U[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'U [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-U.pdf')
        if ('rho' == variable):
            unit = units['density']
            plt.figure()
            outData[f'Rho[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$\\rho$ [g/cm$^3$] ({comp})')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Rho_{comp}.pdf')
        if ('n' == variable):
            plt.figure()
            outData[f'N'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'N {comp}')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-N_{comp}.pdf')
        if ('mu' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Mu[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$\mu$ [{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Mu.pdf')
        if ('l' == variable):
            unit = units['distance']
            dim = 'x'
            plt.figure()
            outData[f'L_{dim}[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'L_{dim} [\\r{{A}}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-L_{dim}.pdf')
    def PlotHistograms(self,outData,fileNumber,variable, comp):
        term = self.termalizationInHists
        components = self.components
        dimensions = self.dimensions
        units = self.units
        outPath,outFileName,outExtension = self.outFilePath
        kde = self.kernelDensity
        if outPath: outPath += 'histograms/' #If output file is in a subdirectory.
        else: outPath = 'histograms/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            plt.figure()
            sns.histplot(data=outData['V[A^3]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['V[A^3]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$V$[A$^3$]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_V.pdf')
        if ('t' == variable):
            plt.figure()
            sns.histplot(data=outData['T[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['T[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$T$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_T.pdf')
        if ('p' == variable):
            plt.figure()
            sns.histplot(data=outData[f'P[{units}]]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'P[{units}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'$P$[{units}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_P.pdf')
        if ('u' == variable):
            plt.figure()
            sns.histplot(data=outData['U[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['U[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_U.pdf')
        if ('mu' == variable):
            plt.figure()
            sns.histplot(data=outData['Mu[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['Mu[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\mu$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Mu_{comp}.pdf')
        if ('idmu' == variable):
            plt.figure()
            sns.histplot(data=outData['IdMu[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['IdMu[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\mu_{\\rm id}$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_IdMu_{comp}.pdf')
        if ('exmu' == variable):
            plt.figure()
            sns.histplot(data=outData[f'ExMu[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['T[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\mu_{\\rm ex}$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_ExMu_{comp}.pdf')
        if ('rho' == variable):
            plt.figure()
            sns.histplot(data=outData[f'Rho[kg/mol]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'Rho[kg/mol]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\\rho$[kg/mol]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Rho_{comp}.pdf')
        if ('n' == variable):
            plt.figure()
            sns.histplot(data=outData[f'N'][term:],bins=50,discrete=True,stat='probability')
            if kde: sns.kdeplot(data=outData[f'N'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$N$')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_N_{comp}.pdf')
        if ('l' == variable):
            dim = 'x'
            plt.figure()
            sns.histplot(data=outData[f'Box-L[A] {dim}'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'Box-L[A] {dim}'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'Box-L[A] {dim}')
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_L_{dim}.pdf')
class Chainbuild(Extract):
    def __init__(self):
        Extract.__init__(self,argv)
        self.listLogFiles, self.listNLogFiles = [], []
        self.solidFileName = ''
        self.molFileName = ''
        self.sigma_ff = self.epsilon_ff = 0
    def ReadInputFiles(self):
        path = self.path
        listInputFiles, listLogFiles, listNLogFiles = [], [], []
        molFileFound = False
        for fileName in os.listdir(path):
            if fileName.endswith('.inp'): listInputFiles.append(fileName)
            elif fileName.endswith('.nlog'): listNLogFiles.append(fileName)
            elif fileName.endswith('.log'): listLogFiles.append(fileName)
            elif fileName.endswith('.sol'): self.solidFileName = fileName
            elif fileName.endswith('.mol'):
                self.molFileName = fileName
                self.ExtractLennardJonesParameters(path+fileName)
                molFileFound = True
        if not molFileFound: print('Error: Molecule file not found. Exiting.'); exit(2)
        listInputFiles.sort(); listLogFiles.sort()
        self.listInFiles = listInputFiles
        self.listNLogFiles = listNLogFiles
        self.listLogFiles = listLogFiles
    def ExtractLennardJonesParameters(self,molFileName):
        with open(molFileName,'r') as molFile: molFileLines = molFile.readlines()
        for line in molFileLines:
            findSigma = re.search(r'sigma1?\s+(\d+\.?\d*)',line)
            findEpsilon = re.search(r'epsilon\s+(\d+\.?\d*)',line)
            if findSigma: self.sigma_ff = float(findSigma.group(1))
            if findEpsilon: self.epsilon_ff = float(findEpsilon.group(1))
        if not (self.sigma_ff and self.epsilon_ff): print('Lennard Jones parameters not found. Exiting.'); exit(2)
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        listLogFiles = self.listLogFiles
        listNLogFiles = self.listNLogFiles
        sections = self.sections
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print( '\tInput files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listInFiles[i]}')
        print( '\tLog files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listLogFiles[i]}')
        print( '\tnLog files:')
        for i in range(len(listInFiles)):
            print(f'\t\t{listNLogFiles[i]}')
    def CallExtractors(self,inputFileName):
        varsToExtract = self.varsToExtract
        dimensions = self.dimensions
        listLogFiles = self.listLogFiles
        listNLogFiles = self.listNLogFiles
        logFileName, nLogFileName = '', ''
        for logFile in listLogFiles: # Look for the log file related to the input file.
            if logFile[:-4] == inputFileName[:-4]:
                logFileName = logFile; break
        if not logFileName: print(f'Log file {inputFileName[:-4]}.log not found. Exiting.'); exit(2)
        for nLogFile in listNLogFiles: # Look for the log file related to the input file.
            if nLogFile[:-5] == inputFileName[:-4]:
                nLogFileName = nLogFile; break
        if not nLogFileName: print(f'nlog file {inputFileName[:-4]}.nlog not found. Exiting.'); exit(2)
        outData = {}
        if ('v' in varsToExtract): outData['V[A^3]'] = self.ExtractVolumes(inputFileName)
        if ('t' in varsToExtract): outData['T[K]'] = self.ExtractTemperatures(inputFileName)
        if ('uff' in varsToExtract): outData['Uff[K]'] = self.ExtractFluidFluidEnergy(logFileName)
        if ('usf' in varsToExtract): outData['Usf[K]'] = self.ExtractSolidFluidEnergy(logFileName)
        if ('idmu' in varsToExtract): outData['IdMu[K]'] = self.ExtractIdealWidomChemicalPotential(logFileName)
        if ('mu' in varsToExtract): outData['Mu[K]'] = self.ExtractChemicalPotential(inputFileName,logFileName)
        if ('rho' in varsToExtract): outData['Rho[A^-3]'] = self.ExtractDensities(inputFileName,logFileName)
        if ('n' in varsToExtract): outData['N'] = self.ExtractNumberOfMolecules(inputFileName,nLogFileName)
        if ('l' in varsToExtract):
            for dim in dimensions:
                outData['Box-L[A]'+f' {dim}'] = self.ExtractBoxLengths(inputFileName,dim)
        return outData
    def ExtractChemicalPotential(self,inputFileName,logFileName):
        path = self.path
        eps = self.epsilon_ff #K
        chemPots = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findEnsemble = re.search( 'ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findEnsemble:
                if findEnsemble.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading chemical potentials from input file.')
                    chemPots.append(float(findEnsemble.group(2)))
                elif findEnsemble.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Reading excess chemical potentials from log file.')
                    with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
                    for line in range(len(fileLines)):
                        findChemPot = re.search( 'mu_ex=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
                        if findChemPot: chemPots.append(float(findChemPot.group(1)))
                break
        if (len(chemPots) == 0):
            print('Warning: Chemical potential was not found from Chainbuild'); chemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots)))*eps #K
    def ExtractIdealWidomChemicalPotential(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        chemPots = []
        for line in range(len(fileLines)-1,0,-1):
            findChemPot = re.search( '<mu_incr>=\s+(-?\d+\.?\d*\w?-?\d*)',fileLines[line])
            if findChemPot:
                chemPots.append(float(findChemPot.group(1))); break #J/(kb*eps_ff)
        if (len(chemPots) == 0):
            print('Warning: Tried to read ideal chemical potential, but simulation hasn\'t ended properly.')
            print('Warning: None ideal chemical potential was not found from Chainbuild.'); chemPots.append(np.nan)
        return pd.Series(chemPots,index=range(len(chemPots)))*epsilon #K
    def ExtractFluidFluidEnergy(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        print('Extracting current fluid-fluid energies per cycle.')
        energies = []
        for line in range(len(fileLines)):
            findEnergy = re.search(r'Uff=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
            if findEnergy: energies.append(float(findEnergy.group(1))) #J/(kb*eps_ff)
        if (len(energies) == 0):
            print('Warning: No fluid-fluid energy was not found from Chainbuild.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))*epsilon #K
    def ExtractSolidFluidEnergy(self,logFileName):
        path = self.path
        epsilon = self.epsilon_ff #K
        with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
        print('Extracting current solid-fluid energies per cycle.')
        energies = []
        for line in range(len(fileLines)):
            findEnergy = re.search(r'Usf=\s+(-?\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
            if findEnergy: energies.append(float(findEnergy.group(1))) #J/(kb*eps_ff)
        if (len(energies) == 0):
            print('Warning: No solid-fluid energy was not found from Chainbuild.'); energies.append(np.nan)
        return pd.Series(energies,index=range(len(energies)))*epsilon #K
    def ExtractNumberOfMolecules(self,inputFileName,nLogFileName):
        path = self.path
        nMolecules = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findNMolecules = re.search(r'ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findNMolecules:
                if findNMolecules.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Reading number of molecules from input file.')
                    nMolecules.append(float(findNMolecules.group(2)))
                elif findNMolecules.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading number of molecules from nlog file.')
                    fileContent = np.loadtxt(path+nLogFileName,dtype='object')
                    nMolecules = list(map(int,fileContent[:,1]))
                break
        if (len(nMolecules) == 0):
            print('Warning: Number of molecules was not found from Chainbuild'); nMolecules.append(np.nan)
        return pd.Series(nMolecules,index=range(len(nMolecules)))
    def ExtractBoxLengths(self,inputFileName,dimLetter):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        solidFileName = self.solidFileName
        boxLengths = []
        print('Warning: Lenghts are not calculated by Chainbuild during simulation.')
        print('Conserved lengths will be extracted.')
        if solidFileName:
            dimension = {'x':1,'y':2,'z':3}
            with open(path+solidFileName,'r') as solidFile: fileLines = solidFile.readlines()
            for line in range(len(fileLines)):
                findLength = re.search(r'(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)',fileLines[line])
                if findLength:
                    boxLengths.append(float(findLength.group(dimension[dimLetter]))); break #nm/sigma_ff
        elif inputFileName:
            with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'solid.+?(-?\d+\.?\d*)',fileLines[line])
                if findLengths:
                    boxLengths.append(float(findLengths.group(1))); break #nm/sigma_ff
        if len(boxLengths) == 0:
            print('Error: Given lengths were not found.'); boxLengths.append(np.nan)
        return pd.Series(boxLengths,index=range(len(boxLengths)))*sigma #Angstrom
    def ExtractVolumes(self,inputFileName):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        solidFileName = self.solidFileName
        volume = []
        print('Warning: Volume is not calculated by Chainbuild during simulation.')
        print('Conserved volume will be extracted.')
        if solidFileName:
            with open(path+solidFileName,'r') as solidFile: fileLines = solidFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)',fileLines[line])
                if findLengths:
                    xLength = float(findLengths.group(1))
                    yLength = float(findLengths.group(2))
                    zLength = float(findLengths.group(3))
                    volume.append(xLength*yLength*zLength) #(nm/sigma_ff)^3
                    break
        elif inputFileName:
            with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
            for line in range(len(fileLines)):
                findLengths = re.search(r'solid.+?(-?\d+\.?\d*)',fileLines[line])
                if findLengths:
                    length = float(findLengths.group(1)) #(nm/sigma_ff)^3
                    volume.append(length**3)
                    break
        if len(volume) == 0:
            print('Error: Volume was not found.'); volume.append(np.nan)
        return pd.Series(volume,index=range(len(volume)))*sigma**3 #A^3
    def ExtractTemperatures(self,inputFileName):
        path = self.path
        print('Warning: Temperature is not calculated by Chainbuild during simulation.')
        print('External temperature will be extracted.')
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        temperature = []
        for line in range(len(fileLines)):
            findTemperature = re.search(r'ens.+?\d+\.?\d*\s+(-?\d+\.?\d*)',fileLines[line])
            if findTemperature:
                temperature.append(float(findTemperature.group(1))); break
        if len(temperature) == 0:
            print('Error: Temperature was not found.'); temperature.append(np.nan)
        return pd.Series(temperature,index=range(len(temperature))) #K
    def ExtractDensities(self,inputFileName,logFileName):
        path = self.path
        sigma = self.sigma_ff #Angstrom
        density = []
        with open(path+inputFileName,'r') as inputFile: fileLines = inputFile.readlines()
        for line in range(len(fileLines)):
            findEnsemble = re.search('ens\s+(\w+)\s+?(-?\d+\.?\d*)',fileLines[line])
            if findEnsemble:
                if findEnsemble.group(1) == 'nvt':
                    print('Ensemble is \"NVT\". Density is not given, but you can calculate it manually.')
                    density.append(np.nan)
                elif findEnsemble.group(1) == 'gce':
                    print('Ensemble is \"GCE\". Reading density from log file.')
                    print('Warning: Density is not calculated by Chainbuild during simulation.')
                    print('Final density will be extracted.')
                    with open(path+logFileName,'r') as logFile: fileLines = logFile.readlines()
                    for line in range(len(fileLines)):
                        findDensity = re.search('<rho>=\s+(\d+\.?\d*\w?[-+]?\d*)',fileLines[line])
                        if findDensity: density.append(float(findDensity.group(1)))
                    if (len(density) == 0):
                        print('Warning: Density was not found from Chainbuild'); density.append(np.nan)
                break
        return pd.Series(density,index=range(len(density)))/sigma**3 #Angstrom^-3
    def PlotVariables(self,outData,fileNumber,variable):
        term = self.termalizationInPlots
        dimensions = self.dimensions
        outPath,outFileName,outExtension = self.outFilePath
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            plt.figure()
            outData['V[A^3]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_V.pdf')
        if ('t' == variable):
            plt.figure()
            outData['T[K]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_T.pdf')
        if ('uff' == variable):
            plt.figure()
            outData['Uff[K]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Uff.pdf')
        if ('usf' == variable):
            plt.figure()
            outData['Usf[K]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Usf.pdf')
        if ('idmu' == variable):
            plt.figure()
            outData['IdMu[K]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_IdMu.pdf')
        if ('mu' == variable):
            plt.figure()
            outData['Mu[K]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Mu.pdf')
        if ('rho' == variable):
            plt.figure()
            outData['Rho[A^-3]'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Rho.pdf')
        if ('n' == variable):
            plt.figure()
            outData['N'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_N.pdf')
        if ('l' == variable):
            for dim in dimensions:
                plt.figure()
                outData[f'Box-L[A] {dim}'][term:].plot(style='.',subplots=True,grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_L_{dim}.pdf')
    def PlotHistograms(self,outData,fileNumber,variable):
        term = self.termalizationInHists
        dimensions = self.dimensions
        outPath,outFileName,outExtension = self.outFilePath
        kde = self.kernelDensity
        if outPath: outPath += 'histograms/' #If output file is in a subdirectory.
        else: outPath = 'histograms/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            plt.figure()
            sns.histplot(data=outData['V[A^3]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['V[A^3]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$V$[A^3]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_V.pdf')
        if ('t' == variable):
            plt.figure()
            sns.histplot(data=outData['T[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['T[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$T$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_T.pdf')
        if ('uff' == variable):
            plt.figure()
            sns.histplot(data=outData['Uff[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['Uff[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U_{\\rm ff}$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Uff.pdf')
        if ('usf' == variable):
            plt.figure()
            sns.histplot(data=outData['Usf[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['Usf[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$U_{\\rm sf}$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Usf.pdf')
        if ('idmu' == variable):
            plt.figure()
            sns.histplot(data=outData['IdMu[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['IdMu[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\mu_{\\rm id}$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_IdMu.pdf')
        if ('mu' == variable):
            plt.figure()
            sns.histplot(data=outData['Mu[K]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['Mu[K]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\mu$[K]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Mu.pdf')
        if ('rho' == variable):
            plt.figure()
            sns.histplot(data=outData['Rho[A^-3]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['Rho[A^-3]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$\\rho [A^{-3}]$')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Rho.pdf')
        if ('n' == variable):
            plt.figure()
            sns.histplot(data=outData['N'][term:],bins=50,discrete=True,stat='probability')
            if kde: sns.kdeplot(data=outData['N'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('$N$')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_N.pdf')
        if ('l' == variable):
            for dim in dimensions:
                plt.figure()
                sns.histplot(data=outData[f'Box-L[A] {dim}'][term:],bins=50,discrete=False,stat='probability')
                if kde: sns.kdeplot(data=outData[f'Box-L[A] {dim}'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel(f'Box-L[A] {dim}')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_L_{dim}.pdf')
class GOMC(Extract):
    def __init__(self):
        Extract.__init__(self,argv)
    def FindComponents(self, logFileName):
        with open(logFileName,'r') as logFile: fileLines = logFile.readlines()
        for line in range(len(fileLines)):
            findComponent = re.search('Molecule Kind:\s+(.+)',fileLines[line])
            if findComponent:
                if findComponent.group(1) in self.components: break
                self.components.append(findComponent.group(1))
    def ReadInputFiles(self):
        path = self.path
        listLogFiles = []
        logFileFound = False
        for fileName in os.listdir(path):
            if fileName.endswith('.log'):
                listLogFiles.append(fileName)
                logFileFound = True
        if not logFileFound: print('Error: Log file not found. Exiting.'); exit(2)
        listLogFiles.sort()
        self.listInFiles = listLogFiles
        self.FindComponents(path+listLogFiles[0])
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        components = self.components
        sections = self.sections
        boxes = self.boxes
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tFluid components: {components}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tSections to analyze: {sections}')
        print(f'\tBoxes to analyze: {boxes}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print( '\tInput files:')
        for i in range(len(listInFiles)): print(f'\t\t{listInFiles[i]}')
    def ReadDataFramesColumns(self, fileLines):
        eTitleColumns, sTitleColumns, mTitleColumns = [], [], []
        foundETitle, foundSTitle, foundMTitle = False, False, False
        for line in range(len(fileLines)):
            findMTitle = re.search('MTITLE:\s+(.+)', fileLines[line])
            findETitle = re.search('ETITLE:\s+(.+)', fileLines[line])
            findSTitle = re.search('STITLE:\s+(.+)', fileLines[line])
            if findETitle and not foundETitle:
                eTitleColumns = findETitle.group(1).split()
                foundETitle = True
            elif findSTitle and not foundSTitle:
                sTitleColumns = findSTitle.group(1).split()
                foundSTitle = True
            elif findMTitle and not foundMTitle:
                mTitleColumns = findMTitle.group(1).split()
                foundMTitle = True
            if foundETitle and foundSTitle and foundMTitle: break
        return mTitleColumns, eTitleColumns, sTitleColumns
    def ReadDataFramesContent(self, fileLines, dataFrameColumns):
        sections = self.sections
        dataFrames = {'Box0':{'Ener':[], 'Stat':[]},
                      'Box1':{'Ener':[], 'Stat':[]}}
        eTitleColumns = dataFrameColumns[1]
        sTitleColumns = dataFrameColumns[2]
        for sec in sections:
            if sec == 'init':
                for line in range(len(fileLines)):
                    findInitialSimulationSection = re.search('INITIAL SIMULATION ENERGY', fileLines[line])
                    if findInitialSimulationSection:
                        for subline in range(line+2,len(fileLines)):
                            findStartingSimulationSection = re.search('STARTING SIMULATION', fileLines[subline])
                            if findStartingSimulationSection: break
                            findEnerBox0 = re.search('ENER_0:\s+(.+)', fileLines[subline])
                            findStatBox0 = re.search('STAT_0:\s+(.+)', fileLines[subline])
                            findPresBox0 = re.search('PRES_0:\s+(.+)', fileLines[subline])
                            findEnerBox1 = re.search('ENER_1:\s+(.+)', fileLines[subline])
                            findStatBox1 = re.search('STAT_1:\s+(.+)', fileLines[subline])
                            findPresBox1 = re.search('PRES_1:\s+(.+)', fileLines[subline])
                            if findEnerBox0:
                                row = np.array(findEnerBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Ener'].append(row)
                            elif findEnerBox1:
                                row = np.array(findEnerBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Ener'].append(row)
                            elif findStatBox0:
                                row = np.array(findStatBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Stat'].append(row)
                            elif findStatBox1:
                                row = np.array(findStatBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Stat'].append(row)
                            elif findPresBox0:
                                row = np.array(findPresBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Pres'].append(row)
                            elif findPresBox1:
                                row = np.array(findPresBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Pres'].append(row)
                        break
            if sec == 'prod':
                for line in range(len(fileLines)):
                    findStartingSimulationSection = re.search('STARTING SIMULATION', fileLines[line])
                    if findStartingSimulationSection:
                        for subline in range(line+2,len(fileLines)):
                            findEnerBox0 = re.search('ENER_0:\s+(.+)', fileLines[subline])
                            findStatBox0 = re.search('STAT_0:\s+(.+)', fileLines[subline])
                            findPresBox0 = re.search('PRES_0:\s+(.+)', fileLines[subline])
                            findEnerBox1 = re.search('ENER_1:\s+(.+)', fileLines[subline])
                            findStatBox1 = re.search('STAT_1:\s+(.+)', fileLines[subline])
                            findPresBox0 = re.search('PRES_1:\s+(.+)', fileLines[subline])
                            if findEnerBox0:
                                row = np.array(findEnerBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Ener'].append(row)
                            elif findEnerBox1:
                                row = np.array(findEnerBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Ener'].append(row)
                            elif findStatBox0:
                                row = np.array(findStatBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Stat'].append(row)
                            elif findStatBox1:
                                row = np.array(findStatBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Stat'].append(row)
                            elif findPresBox0:
                                row = np.array(findPresBox0.group(1).split(),dtype='float')
                                dataFrames['Box0']['Pres'].append(row)
                            elif findPresBox1:
                                row = np.array(findPresBox1.group(1).split(),dtype='float')
                                dataFrames['Box1']['Pres'].append(row)
        for box in dataFrames.keys():
            dataFrames[box]['Ener'] = pd.DataFrame(data=dataFrames[box]['Ener'],columns=eTitleColumns)
            dataFrames[box]['Stat'] = pd.DataFrame(data=dataFrames[box]['Stat'],columns=sTitleColumns)
        return dataFrames
    def CallExtractors(self, fileName):
        path = self.path
        varsToExtract = self.varsToExtract
        components = self.components
        dimensions = self.dimensions
        boxes = self.boxes
        outData = {}
        with open(path+fileName,'r') as fileContent: fileLines = fileContent.readlines()
        dataFrameColumns = self.ReadDataFramesColumns(fileLines)
        dataFrames = self.ReadDataFramesContent(fileLines, dataFrameColumns)
        for box in boxes:
            if ('v' in varsToExtract): outData[f'Box{box}-V[A^3]'] = self.ExtractVolumes(fileLines, box)
            if ('t' in varsToExtract): outData[f'Box{box}-T[K]'] = self.ExtractTemperatures(fileLines, box)
            if ('p' in varsToExtract):
                for comp in components:
                    outData[f'Box{box}-P[bar]'] = self.ExtractPressures(fileLines, box, comp)
            if ('u' in varsToExtract): outData[f'Box{box}-U[K]'] = self.ExtractInternalEnergy(dataFrames, box)
            if ('rho' in varsToExtract):
                for comp in components:
                    outData[f'Box{box}-Rho[kg/m^3] {comp}'] = self.ExtractDensities(dataFrames, box, comp)
            if ('n' in varsToExtract):
                for comp in components:
                    outData[f'Box{box}-N {comp}'] = self.ExtractNumberOfMolecules(dataFrames, box, comp)
            if ('l' in varsToExtract):
                for dim in dimensions:
                    outData[f'Box{box}-L[A] {dim}'] = self.ExtractBoxLengths(box, fileLines, dim)
        return outData
    def ExtractVolumes(self, fileLines, box):
        minLengths, maxLengths, boxLengths = [], [], []
        foundMinLengths, foundMaxLengths = False, False
        indices = [2, 5, 8]
        volume = 0
        print(f'Warning: Only initial volume of box {box} will be extracted.')
        for line in range(len(fileLines)):
            if foundMinLengths and foundMaxLengths: break
            findMinLengths = re.search(f'Minimum coordinates in box {box}:\s+(.+)',fileLines[line])
            findMaxLengths = re.search(f'Maximum coordinates in box {box}:\s+(.+)',fileLines[line])
            if findMinLengths:
                minLengths = np.array(findMinLengths.group(1).split())[indices]
                minLengths[0] = minLengths[0][:-1]
                minLengths[1] = minLengths[1][:-1]
                foundMinLengths = True
            elif findMaxLengths:
                maxLengths = np.array(findMaxLengths.group(1).split())[indices]
                maxLengths[0] = maxLengths[0][:-1]
                maxLengths[1] = maxLengths[1][:-1]
        boxLengths = maxLengths.astype('float') - minLengths.astype('float')
        volume = boxLengths[0]*boxLengths[1]*boxLengths[2] #A^3
        return pd.Series([volume],index=range(1))
    def ExtractTemperatures(self, fileLines, box):
        temperatures = []
        print('Warning: Only initial temperature will be extracted.')
        for line in range(len(fileLines)):
            findTemperature = re.search('Input Temperature\s+(\d+\.\d+)',fileLines[line])
            if findTemperature:
                temperatures.append(float(findTemperature.group(1))); break #K
        return pd.Series(temperatures,index=range(1))
    def ExtractPressures(self, fileLines, box, comp):
        fugacities = []
        foundFugacity = False
        for line in range(len(fileLines)):
            findFugacity = re.search(f'Info: Fugacity\s+{comp}\s+(\d+\.?\d*)',fileLines[line])
            if findFugacity:
                if not foundFugacity:
                    print('Warning: Only initial fugacities will be extracted.')
                    foundFugacity = True
                fugacities.append(float(findFugacity.group(1))); break #K
        if len(fugacities) == 0:
            print('Warning: No fugacities were found.'); fugacities.append(np.nan)
        return pd.Series(fugacities,index=range(1))
    def ExtractInternalEnergy(self, dataFrames, box):
        if box == 0: return dataFrames['Box0']['Ener']['TOTAL']
        elif box == 1: return dataFrames['Box1']['Ener']['TOTAL']
    def ExtractDensities(self, dataFrames, box, comp):
        if box == 0:
            densityFraction = dataFrames['Box0']['Stat'][f'MOLDENS_{comp}']
            totalDensity = dataFrames['Box0']['Stat']['TOT_DENSITY']
            return densityFraction*totalDensity
        elif box == 1:
            densityFraction = dataFrames['Box1']['Stat'][f'MOLDENS_{comp}']
            totalDensity = dataFrames['Box1']['Stat']['TOT_DENSITY']
            return densityFraction*totalDensity
    def ExtractNumberOfMolecules(self, dataFrames, box, comp):
        if box == 0:
            molFraction = dataFrames['Box0']['Stat'][f'MOLFRAC_{comp}'].round()
            totalMol = dataFrames['Box0']['Stat']['TOTALMOL'].round()
            return molFraction*totalMol
        elif box == 1:
            molFraction = dataFrames['Box1']['Stat'][f'MOLFRAC_{comp}'].round()
            totalMol = dataFrames['Box1']['Stat']['TOTALMOL'].round()
            return molFraction*totalMol
    def ExtractBoxLengths(self, box, fileLines, dimLetter):
        dimension = {'x':0,'y':1,'z':2}
        indices = [2, 5, 8]
        minLengths, maxLengths, boxLengths = [], [], []
        foundMinLengths, foundMaxLengths = False, False
        print(f'Warning: Only initial dimension {dimLetter} of box {box} will be extracted.')
        for line in range(len(fileLines)):
            if foundMinLengths and foundMaxLengths: break
            findMinLengths = re.search(f'Minimum coordinates in box {box}:\s+(.+)',fileLines[line])
            findMaxLengths = re.search(f'Maximum coordinates in box {box}:\s+(.+)',fileLines[line])
            if findMinLengths:
                minLengths = np.array(findMinLengths.group(1).split())[indices]
                minLengths[0] = minLengths[0][:-1]
                minLengths[1] = minLengths[1][:-1]
                foundMinLengths = True
            elif findMaxLengths:
                maxLengths = np.array(findMaxLengths.group(1).split())[indices]
                maxLengths[0] = maxLengths[0][:-1]
                maxLengths[1] = maxLengths[1][:-1]
        boxLengths = maxLengths.astype('float') - minLengths.astype('float')
        return pd.Series([boxLengths[dimension[dimLetter]]],index=range(1))
    def PlotHistograms(self, outData, fileNumber, variable):
        term = self.termalizationInHists
        components = self.components
        dimensions = self.dimensions
        outPath,outFileName,outExtension = self.outFilePath
        boxes = self.boxes
        if outPath: outPath += 'histograms/' #If output file is in a subdirectory.
        else: outPath = 'histograms/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        for box in boxes:
            if ('v' == variable):
                plt.figure()
                outData[f'Box{box}-V[A^3]'][term:].plot(bins=50,kind='hist')
                plt.xlabel('V[A^3]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-V.pdf')
            if ('t' == variable):
                plt.figure()
                outData[f'Box{box}-T[K]'][term:].plot(bins=50,kind='hist')
                plt.xlabel('T[K]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-T.pdf')
            if ('p' == variable):
                plt.figure()
                outData[f'Box{box}-P[bar]'][term:].plot(bins=50,kind='hist')
                plt.xlabel('P[bar]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-P.pdf')
            if ('u' == variable):
                plt.figure()
                outData[f'Box{box}-U[K]'][term:].plot(bins=50,kind='hist')
                plt.xlabel('U[K]')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-U.pdf')
            if ('rho' == variable):
                for comp in components:
                    plt.figure()
                    outData[f'Box{box}-Rho[kg/mol] {comp}'][term:].plot(bins=50,kind='hist')
                    plt.xlabel('Rho[kg/mol]')
                    plt.tight_layout()
                    plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-Rho_{comp}.pdf')
            if ('n' == variable):
                for comp in components:
                    plt.figure()
                    outData[f'Box{box}-N {comp}'][term:].plot(bins=50,kind='hist')
                    plt.xlabel('N')
                    plt.tight_layout()
                    plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-N_{comp}.pdf')
            if ('l' == variable):
                for dim in dimensions:
                    plt.figure()
                    outData[f'Box{box}-L[A] {dim}'][term:].plot(bins=50,kind='hist')
                    plt.xlabel(f'Box-L[A] {dim}')
                    plt.savefig(f'{outPath}/{fileNumber}_{outFileName}_Box{box}-L_{dim}.pdf')
class LAMMPS(Extract):
    def __init__(self):
        Extract.__init__(self, argv)
        self.units = {}
        self.unitStyle = ''
    def ReadInputFiles(self):
        path = self.path
        listInpFiles = []
        inpFileFound = False
        for fileName in os.listdir(path):
            if fileName.endswith('.out'):
                listInpFiles.append(fileName)
                inpFileFound = True
        if not inpFileFound: print('Error: Input file not found. Exiting.'); exit(2)
        self.ReadUnits(listInpFiles[0])
        listInpFiles.sort()
        self.listInFiles = listInpFiles
    def ReadUnits(self, inpFileName):
        path = self.path
        findUnitStyle = False
        unitStyle = 0
        units = {}
        with open(path+inpFileName, 'r') as file: fileLines = file.readlines()
        for line in fileLines:
            findUnitStyle = re.search('Unit style\s+:\s+(.+)', line)
            if findUnitStyle:
                unitStyle = findUnitStyle.group(1)
                break
        if not findUnitStyle: print('Error: Units not found. Exiting.'); exit(2)
        if unitStyle == 'metal':
            units['mass'] = 'g/mol'
            units['distance'] = 'A'
            units['volume'] = 'A$^3$'
            units['time'] = 'ps'
            units['energy'] = 'eV'
            units['temperature'] = 'K'
            units['pressure'] = 'bar'
            units['charge'] = 'e'
            units['density'] = 'g/cm$^3$'
        elif unitStyle == 'lj':
            units['mass'] = ''
            units['distance'] = ''
            units['volume'] = ''
            units['time'] = ''
            units['energy'] = ''
            units['temperature'] = ''
            units['pressure'] = ''
            units['charge'] = ''
        self.units = units
        self.unitStyle = unitStyle
    def PrintInputParameters(self):
        path = self.path
        varsToExtract = self.varsToExtract
        unitStyle = self.unitStyle
        sort = self.sort
        dimensions = self.dimensions
        createFigures = self.createFigures
        outFileName, createOutFile = self.outFile
        listInFiles = self.listInFiles
        print(f'\tInput path: {path}')
        print(f'\tVariables to extract: {varsToExtract}')
        print(f'\tUnits style: {unitStyle}')
        print(f'\tSort variables according to: {sort}')
        print(f'\tBox dimensions: {dimensions}')
        print(f'\tCreate figures: {createFigures}')
        print(f'\tCreate output file: {createOutFile}')
        print( '\tInput files:')
        for i in range(len(listInFiles)): print(f'\t\t{listInFiles[i]}')
    def ReadDataFrame(self, fileLines, fileName):
        path = self.path
        nRows, headerLine = 0, 0
        for line in range(len(fileLines)-1,0,-1):
            findDataHeader = re.search('Per MPI rank memory allocation', fileLines[line])
            if findDataHeader:
                headerLine = line+1
                for subline in range(line+1,len(fileLines)):
                    findDataFooter = re.search('Loop time of', fileLines[subline])
                    if findDataFooter:
                        nRows = subline
                        break
                break
        if not findDataHeader: exit(f'No header found for file {fileName}. Exiting program.')
        if not findDataFooter:
            print('Ending of simulation not found. Proceeding analysis with present data.')
            dataFrame = pd.read_csv(path+fileName, engine='python', delimiter='\s+', skiprows=headerLine)
        else:
            dataFrame = pd.read_csv(path+fileName, engine='python', delimiter='\s+', skiprows=headerLine,
                                    nrows=nRows-headerLine-1)
        return dataFrame
    def CallExtractors(self, fileName): #Check!
        path = self.path
        varsToExtract = self.varsToExtract
        dimensions = self.dimensions
        units = self.units
        outData = {}
        with open(path+fileName,'r') as fileContent: fileLines = fileContent.readlines()
        dataFrame = self.ReadDataFrame(fileLines, fileName)
        if ('s' in varsToExtract):
            outData['Step'] = dataFrame['Step']
        if ('v' in varsToExtract):
            unit = units['volume']
            outData[f'V[{unit}]'] = dataFrame['Volume']
        if ('t' in varsToExtract):
            unit = units['temperature']
            outData[f'T[{unit}]'] = dataFrame['Temp']
        if ('p' in varsToExtract):
            unit = units['pressure']
            outData[f'P[{unit}]'] = dataFrame['Press']
        if ('u' in varsToExtract):
            unit = units['energy']
            outData[f'U[{unit}]'] = dataFrame['TotEng']
        if ('n' in varsToExtract): outData['N'] = dataFrame['Atoms']
        if ('rho' in varsToExtract):
            unit = units['density']
            outData[f'Rho[{unit}]'] = dataFrame['Density']
        if ('l' in varsToExtract):
            unit = units['distance']
            for dim in dimensions: outData[f'L[{unit}] {dim}'] = dataFrame[f'L{dim}']
        for variable in varsToExtract:
            if ('_' in variable):
                outData[f'{variable}'] = dataFrame[f'{variable}']
        return outData
    def PlotHistograms(self, outData, fileNumber, variable):
        term = self.termalizationInHists
        dimensions = self.dimensions
        units = self.units
        kde = self.kernelDensity
        outPath,outFileName,outExtension = self.outFilePath
        if outPath: outPath += 'histograms/' #If output file is in a subdirectory.
        else: outPath = 'histograms/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            unit = units['volume']
            plt.figure()
            sns.histplot(data=outData[f'V[{unit}]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'V[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'V[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-V.pdf')
        if ('t' == variable):
            unit = units['temperature']
            plt.figure()
            sns.histplot(data=outData[f'T[{unit}]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'T[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'T[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-T.pdf')
        if ('p' == variable):
            unit = units['pressure']
            plt.figure()
            sns.histplot(data=outData[f'P[{unit}]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'P[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'P[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-P.pdf')
        if ('u' == variable):
            unit = units['energy']
            plt.figure()
            sns.histplot(data=outData[f'U[{unit}]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'U[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'U[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-U.pdf')
        if ('rho' == variable):
            unit = units['density']
            plt.figure()
            sns.histplot(data=outData[f'Rho[{unit}]'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'Rho[{unit}]'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'Rho[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Rho.pdf')
        if ('n' == variable):
            plt.figure()
            sns.histplot(data=outData['N'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData['N'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel('N')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-N.pdf')
        if ('l' == variable):
            unit = units['distance']
            for dim in dimensions:
                plt.figure()
                sns.histplot(data=outData[f'L[{unit}] {dim}'][term:],bins=50,discrete=False,stat='probability')
                if kde: sns.kdeplot(data=outData[f'L[{unit}] {dim}'][term:],bw_adjust=3,color='r',linewidth=5)
                plt.xlabel(f'L[{unit}] {dim}')
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-L_{dim}.pdf')
        if ('_' in variable):
            plt.figure()
            sns.histplot(data=outData[f'{variable}'][term:],bins=50,discrete=False,stat='probability')
            if kde: sns.kdeplot(data=outData[f'{variable}'][term:],bw_adjust=3,color='r',linewidth=5)
            plt.xlabel(f'{variable}')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-{variable}.pdf')
    def PlotVariables(self, outData, fileNumber, variable):
        term = self.termalizationInPlots
        dimensions = self.dimensions
        units = self.units
        outPath,outFileName,outExtension = self.outFilePath
        if outPath: outPath += 'Figures/' #If output file is in a subdirectory.
        else: outPath = 'Figures/' #If output file is not in a subdirectory.
        os.makedirs(outPath, exist_ok=True)
        if ('v' == variable):
            unit = units['volume']
            plt.figure()
            outData[f'V[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets or cycles)')
            plt.ylabel(f'V[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-V.pdf')
        if ('t' == variable):
            unit = units['temperature']
            plt.figure()
            outData[f'T[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'T[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-T.pdf')
        if ('p' == variable):
            unit = units['pressure']
            plt.figure()
            outData[f'P[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'P[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-P.pdf')
        if ('u' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'U[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'U[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-U.pdf')
        if ('rho' == variable):
            unit = units['density']
            plt.figure()
            outData[f'Rho[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$\\rho$[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Rho.pdf')
        if ('n' == variable):
            plt.figure()
            outData['N'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel('N')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-N.pdf')
        if ('mu' == variable):
            unit = units['energy']
            plt.figure()
            outData[f'Mu[{unit}]'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'$\mu$[{unit}]')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-Mu.pdf')
        if ('l' == variable):
            unit = units['distance']
            for dim in dimensions:
                plt.figure()
                outData[f'L[{unit}] {dim}'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
                plt.ylabel(f'L[{unit}] {dim}')
                plt.tight_layout()
                plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-L_{dim}.pdf')
        if ('_' in variable):
            plt.figure()
            outData[f'{variable}'][term:].plot(style='.',grid=True,xlabel='Evolution of simulation (steps, sets of cycles)')
            plt.ylabel(f'{variable}')
            plt.tight_layout()
            plt.savefig(f'{outPath}/{fileNumber}_{outFileName}-{variable}.pdf')
class SummarizeDataFrames():
    def __init__(self,dataFilesPath,groups,sort,joinDataFrames,countFrom):
        self.dataFilesPath = dataFilesPath
        self.groups = groups.split()
        self.joinDataFrames = joinDataFrames
        self.countDataFrom = countFrom
        self.sortDataFramesBy = sort
        self.summedDataFrame, self.summedDataFrames, self.groupedDataFrames = {}, {}, {}
    def SearchDataFiles(self):
        dataFilesPath = self.dataFilesPath
        groups = self.groups
        countFrom = self.countDataFrom
        dataFileNames = os.listdir(dataFilesPath)
        groupedDataFrames = {i:[] for i in groups}
        for dataFile in dataFileNames:
            dataFrame = pd.read_csv(dataFilesPath+dataFile,sep='\t',encoding='unicode_escape')
            dataFrame = dataFrame[countFrom:]
            for i in groups:
                if re.search(i,dataFile): groupedDataFrames[i].append(dataFrame)
        self.groupedDataFrames = groupedDataFrames
    def JoinDataFrames(self):
        sort = self.sortDataFramesBy
        dataFrames = self.summedDataFrames
        concatDataFrame = pd.concat(dataFrames).reset_index()
        concatDataFrame.drop(columns={'level_1'},inplace=True)
        concatDataFrame.rename(columns={'level_0':'Group'},inplace=True)
        for key in concatDataFrame.columns:
            findSortValue = re.search(f'^{sort}\[.+',key)
            if findSortValue: concatDataFrame.sort_values(findSortValue.group(),ignore_index=True,inplace=True)
        print('Data Frame:\n')
        print(concatDataFrame)
        self.summedDataFrame = concatDataFrame
    def SetSummedDataFrames(self):
        groups = self.groups
        summedDataFrames = self.summedDataFrames
        for i in groups: summedDataFrames[i] = pd.DataFrame(columns=[])
        self.summedDataFrames = summedDataFrames
    def CreateSummedDataFrames(self):
        sort = self.sortDataFramesBy
        groups = self.groups
        groupedDataFrames = self.groupedDataFrames
        summedDataFrames = self.summedDataFrames
        for i in groups:
            group = groupedDataFrames[i]
            nDataFrames = len(group)
            sampleSizes = np.zeros(nDataFrames)
            sqrGroupVar = np.zeros(nDataFrames,dtype='object')
            averages, variances = np.zeros(nDataFrames), np.zeros(nDataFrames)
            modes, medians = np.zeros(nDataFrames), np.zeros(nDataFrames)
            moe, moeSqr, moeVar = np.zeros(nDataFrames), np.zeros(nDataFrames), np.zeros(nDataFrames)
            for variable in group[0].columns:
                for j in range(nDataFrames):
                    group[j][variable].replace(-np.inf, np.nan, inplace=True)
                    sampleSizes[j] = len(group[j][variable])
                    kde = KernelDensity(bandwidth=1.0, kernel='gaussian').fit(group[j][[variable]])
                    density = np.exp(kde.score_samples(group[j][[variable]]))
                    tmp = group[j][variable][density == density.max()]
                    modes[j] = tmp.iloc[0]
                    medians[j] = group[j][variable].median()
                    averages[j] = group[j][variable].mean()
                    variances[j] = group[j][variable].std()
                    tmp = group[j][variable].to_numpy(dtype='float', copy=True)
                    tmp2 = group[j][variable]**2
                    tmp2 = tmp2.to_numpy(dtype='float', copy=True)
                    moe[j] = np.sqrt(MeanFluctuations(tmp, variable))
                    moeVar[j] = np.sqrt(VarianceFluctuations(tmp, variable))
                    moeSqr[j] = np.sqrt(MeanFluctuations(tmp2, variable))
                summedDataFrames[i][f'size{variable}'] = pd.Series(sampleSizes)
                summedDataFrames[i][variable] = pd.Series(averages)
                summedDataFrames[i][f'Mode({variable})'] = pd.Series(modes)
                summedDataFrames[i][f'Median({variable})'] = pd.Series(medians)
                summedDataFrames[i][f'Var({variable})'] = pd.Series(variances)
                summedDataFrames[i][f'MOE({variable})'] = pd.Series(moe)
                summedDataFrames[i][f'MOE(({variable})^2)'] = pd.Series(moeSqr)
                summedDataFrames[i][f'MOE(Var({variable}))'] = pd.Series(moeVar)
            summedDataFrames[i].sort_values(sort,ignore_index=True,inplace=True)
        self.summedDataFrames = summedDataFrames
    def Extract(self):
        self.SearchDataFiles()
        self.SetSummedDataFrames()
        self.CreateSummedDataFrames()
        dataFrames = self.summedDataFrames
        groups = self.groups
        for i in groups:
            print('\n'+i)
            print(dataFrames[i])
def SumUpDataFrames(dataFilesPath,groups,sortDataFrames,joinDataFrames,countDataFrom):
    data = SummarizeDataFrames(dataFilesPath,groups,sortDataFrames,joinDataFrames,countDataFrom)
    data.Extract()
    if joinDataFrames:
        data.JoinDataFrames()
        return data.summedDataFrame
    else: return data.summedDataFrames
def MeanFluctuations(pdSeries, variable):
    step = 0
    runVar = pdSeries.var()
    runMean = pdSeries.mean()
    statIneffs = np.ones(50)
    sampleSize = len(pdSeries)
    if (round(runVar, 5) == 0.0 or np.isnan(runVar) or np.isinf(runVar)): return 0.0
    for j in np.logspace(1, np.log10(int(sampleSize*0.5))):
        blocks = pdSeries.copy()
        nGroupedBlocks = round(j)
        blocks = blocks[len(blocks)%nGroupedBlocks:]
        blocks = blocks.reshape(-1, nGroupedBlocks).mean(axis=1)
        tauBlock = sampleSize/len(blocks)
        blockVar = (blocks-runMean)**2
        blockVar = np.sum(blockVar)/(len(blocks)-1)
        statIneff = tauBlock*blockVar/runVar
        if (statIneff < 1): continue
        statIneffs[step] = statIneff
        step += 1
    variance = statIneffs.max()*runVar/sampleSize
    return variance
def VarianceFluctuations(pdSeries, variable):
    step = 0
    runVar = pdSeries.var()
    statIneffs = np.ones(50)
    sampleSize = len(pdSeries)
    if (round(runVar, 5) == 0.0 or np.isnan(runVar) or np.isinf(runVar)): return 0.0
    for j in np.logspace(1, np.log10(int(sampleSize*0.5))):
        blocks = pdSeries.copy()
        nGroupedBlocks = round(j)
        blocks = blocks[len(blocks)%nGroupedBlocks:]
        blocks = blocks.reshape(-1, nGroupedBlocks).var(axis=1)
        tauBlock = sampleSize/len(blocks)
        blockVar = (blocks-runVar)**2
        blockVar = np.sum(blockVar)/(len(blocks)-1)
        statIneff = tauBlock*blockVar/runVar
        if (statIneff < 1): continue
        statIneffs[step] = statIneff
        step += 1
    variance = statIneff.min()*runVar/sampleSize
    return variance
def Help():
    print('\nDescription:')
    print('\tThis script extracts the output data generated by RASPA or Chainbuild, and saves them as data frames.')
    print('Requirements: Numpy and Pandas libraries must be installed.')
    print('Instructions:')
    print('\tpython3 extractData.py [-[Flag] [Arguments]] [-[Flag] [Arguments]] ...')
    print('\tFlags allowed for RASPA and Chainbuild:')
    print('\t\t-h or -H: Call for help.')
    print('\t\t\tEquilibration cycles (if added), are included in initialization cycles.')
    print('\t\t-s or -S: Sort data frame according to a given value. By default, it\'s pressure (P).')
    print('\t\t\tIt can be sorted according to only one value, which must be one of the variables given after the flag -v (or -V).')
    print('\t\t-f or -F: Plot the evolution of variables along the cycles.')
    print('\t\t-ef or -EF: Indicate termalization for the plots mentioned above (initial point to analyze the data).')
    print('\t\t\tThe plot file will be outputFile.pdf, where outputFile is indicated by the -o flag.')
    print('\t\t-p or -P: Print input parameters.')
    print('\t\t-i or -I: Indicate the path where the data file is found. By default: Output/System_0')
    print('\t\t-o or -O: Indicate the "path/fileName" where the extracted data will be printed.')
    print('\t\t\tIf you have several files in the input path given, this script will extract them all and enumerate them as i_fileName, where i is an integer number.')
    print('\t\t\tBy default (if you don\'t set output path), no file is created.')
    print('\t\t-d or -D: List of dimensions to extract the box-lengths. By deafault, the three dimensions.')
    print('\t\t-a or -A: List of angles to extract the box-angles. By deafault, the three angles.')
    print('\t\t-v or -V: Indicate the list of variables that will be extracted. By default: N.')
    print('\t\t-g or -G: Indicate the list of variables that will be extracted to plot their respective histograms. By default: N.')
    print('\t\t-eh or -EH: Indicate termalization for histograms (initial point to analyze the data).')
    print('\tFlags allowed only for RASPA:')
    print('\t\t-t or -T: The types of cycles to analyze: Production cycles (prod) or initialization cycles (init). By default: init and prod')
    print('\t\t-u or -U: Indicate the units for the pressure (kPa, atm or bar). By default: kPa')
    print('\tVariables allowed for RASPA and Chainbuild:')
    print('\t\tV: Volume in A^3.')
    print('\t\tT: Temperature in K.')
    print('\t\tIdMu: Ideal-gas Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tL: Box-length in A.')
    print('\t\tN: Number of molecules/atoms.')
    print('\tVariables allowed only for RASPA:')
    print('\t\tP: Pressure in kPa.')
    print('\t\t\tThree different units can be specified: kPa, atm or bar. By default, kPa.')
    print('\t\tU: Internal energy in K (J/kb).')
    print('\t\tMu: Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tExMu: Excess Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tSimulation must have ended to be extracted.')
    print('\t\tRho: Density in kg/m^3.')
    print('\tVariables allowed only for Chainbuild:')
    print('\t\tUff: Internal energy for fluid-fluid interactions in K (J/kb).')
    print('\t\tUsf: Internal energy for solid-fluid interactions in K (J/kb).')
    print('\t\tMu: Excess Chemical Potential in K (J/kb) by Widom insertion method.')
    print('\t\t\tIf the ensemble is Grand Canonical, it will extract the given chemical potentials.')
    print('\t\tRho: Density in A^-3.')
    print('Example:')
    print('\tThe following command would extract the volume and internal energy of a methane-benzene binary mixture from Output/System_1 from RASPA,')
    print('\tas well as the pressures (in atm) and the box-length in the x axis.')
    print('\tThe extracted data would be saved in the directory grouped_data, and in the files i_excessProps.dat, where i is a number given by this script.')
    print('\tpython3 extractData.py -m Raspa -I Outputs/System_1/ -o grouped_data/excessProps.dat -t prod -v U V P L -U atm -d x -p -s P')
    print('\tThe following command would extract the volume, number of molecules and fluid-fluid internal energy of nitrogen both from Chainbuild.')
    print('\tThe extracted data would be saved in the directory grouped_data and as files outData.dat, and sorted according to the number of molecules.')
    print('\tpython3 extractData.py -m Chainbuild -I ./ -o ./grouped_data/outData.dat -v V N Uff -p -s N')
    print('Note: The file name usually works as the group name as each file will be numbered according to the fileName given.')
    print('\n')
    print('Once you grouped your data into a single directory, you can use an independent script to sum up the given data and do your own analysis.')
    print('1.- In your script, import this file: import extractData as ed')
    print('2.- Give the following information:')
    print('    \t- string: Path where the data files are located. Let\'s call it "dataFilesPath".')
    print('    \t- string: List of the groups of the extracted data (separated by spaces). Call it "groups".')
    print('    \t- string: The variable that you\'ll use to sort your summed data. Call it "sortDataFrames".')
    print('    \t- string: Indicate from what points you want to do your analysis (to avoid biased data). You can check the extracted figures to see from what points')
    print('    \t     your system has reached equilibrium. Call it "countDataFrom".')
    print('    \t- boolean: Indicate if you want to create a single data frame with your grouped data or separate data frames (one per group). Call it "joinDataFrames"')
    print('3.- Create a dictionary that will contain your summed data: dataFrames = ed.SumUpDataFrames(dataFilesPath, groups, sortDataFrames, countDataFrom, joinDataFrames)')
    print('    If you don\'t join your data frames, each dataFrames\'s key will be a group (fileName), and inside each group, you will have your summed data frame.')
    print('    If you join them all, there will be a single data frame with an extra column called "Group".')
    print('Note: your data frames were created using the library pandas, so you can take advantage of the library to analyze the data.')
    print('The file analyzeData.py is an example of a script that would do an analysis.')
    exit(1)
##########################################################################################################
if __name__ == '__main__':
    print('Author: Santiago A. Flores Roman')
    argvString = ' '.join(argv)
    print(f'\nCommand line being executed:\n{argvString}')
    # if re.search(r'-h+',argvString.lower()): Help()
    print('\nChecking simulation program...')
    extract = 0
    checkMotor = re.search(r'-program\s+([\w-]+)\s+',argvString.lower())
    if checkMotor:
        motor = checkMotor.group(1)
        if motor == 'raspa': print('RASPA'); extract = Raspa()
        elif motor == 'mezcal': print('MezCal'); extract = MezCal()
        elif motor == 'chainbuild': print('Chainbuild'); extract = Chainbuild()
        elif motor == 'gomc': print('GOMC'); extract = GOMC()
        elif motor == 'lammps': print('LAMMPS'); extract = LAMMPS()
        else: print(f'Error: Simulation program not known: {motor}. Exiting.'); exit(2)
    else: print('Error: No simulation program found. Exiting.'); exit(2)
    print('\nReading input parameters...')
    extract.Flags()
    print('\nReading input files...')
    extract.ReadInputFiles()
    if extract.printInputParams == True:
        print('\nInput parameters:\n')
        extract.PrintInputParameters()
    extract.ExtractData()

# EOS
